# A stack implementation

# Size of the stack
.CONST stack_size 100
# ORed with %F if a stack overflow occurs
.CONST stack_overflow_error_bit 1
# ORed with %F if a stack underflow occurs
.CONST stack_underflow_error_bit 2

..DATA
ALLOC 69 # To test that the stack still works even when it does not start at RAM address 0
PUSH -1 # To mark the boundary before the sack
.LABEL stack_ptr
PUSH stack_start # Point at the top of the stack
.LABEL stack_start
ALLOC stack_size
PUSH -1 # To mark the boundary after the sack

# Public
# Inputs:
# - The value to push at the top of the stack
# Outputs:
# - Empty stack
# Registers:
# - Uses %0 to %3
# - Sets error bits in %F
..ROM 1
# (value) -> ()
.LABEL stack_push
POP r0
PUSH stack_ptr
KREAD
POP r1
PUSH stack_start + stack_size
POP r3
INPUT
CMP r3
.USEFLAGS
BRANCH EQ stack_push_stack_overflow
KWRITE r0
INC
POP r2
PUSH r1
PWRITE r2
RETURN
.LABEL stack_push_stack_overflow
POPNOOP
PUSH stack_overflow_error_bit
OR r15
POP r15
RETURN

# Public
# Inputs:
# - Nothing
# Outputs:
# - Popped value at the top of the stack
# Registers:
# - Uses %0 %1 %2
# - Sets error bits in %F
.LABEL stack_pop
PUSH stack_ptr
KREAD
POP r1
PUSH stack_start
POP r2
INPUT
CMP r2
.USEFLAGS
DEC
BRANCH EQ stack_push_stack_underflow
KREAD
POP r0
PUSH r1
PWRITE r0
INPUT
RETURN

.LABEL stack_push_stack_underflow
POPNOOP
PUSH stack_underflow_error_bit
OR r15
POP r15
RETURN


# Example usage
..ROM 0
PUSH 1 CALL stack_push
PUSH 2 CALL stack_push
CALL stack_pop
PUSH 3 CALL stack_push
PUSH 4 CALL stack_push
CALL stack_pop
CALL stack_pop
CALL stack_pop
RETURN