# A stack implementation

# Size of the stack
.CONST stack_size 100
# ORed with %F if a stack overflow occurs
.CONST stack_overflow_error_bit 1
# ORed with %F if a stack underflow occurs
.CONST stack_underflow_error_bit 2

..DATA
ALLOC 69 # To test that the stack still works even when it does not start at RAM address 0
VALUE -1 # To mark the boundary before the sack
.LABEL stack_ptr
VALUE stack_start # Point at the top of the stack
.LABEL stack_start
ALLOC stack_size
VALUE -1 # To mark the boundary after the sack

# Public
# Inputs:
# - The value to push at the top of the stack
# Outputs:
# - Empty stack
# Registers:
# - Uses %0 to %3
# - Sets error bits in %F
..ROM 1
# (value) -> ()
.LABEL stack_push
POP %0
VALUE stack_ptr
KREAD
POP %1
VALUE stack_start + stack_size
POP %3
INPUT
CMP %3
.USEFLAGS
BRANCH EQ stack_push_stack_overflow
KWRITE %0
INC
POP %2
PUSH %1
PWRITE %2
RETURN
.LABEL stack_push_stack_overflow
POPNOOP
VALUE stack_overflow_error_bit
OR %F
POP %F
RETURN

# Public
# Inputs:
# - Nothing
# Outputs:
# - Popped value at the top of the stack
# Registers:
# - Uses %0 %1 %2
# - Sets error bits in %F
.LABEL stack_pop
VALUE stack_ptr
KREAD
POP %1
VALUE stack_start
POP %2
INPUT
CMP %2
.USEFLAGS
DEC
BRANCH EQ stack_push_stack_underflow
KREAD
POP %0
PUSH %1
PWRITE %0
INPUT
RETURN

.LABEL stack_push_stack_underflow
POPNOOP
VALUE stack_underflow_error_bit
OR %F
POP %F
RETURN


# Example usage
..ROM 0
VALUE 1 CALL stack_push
VALUE 2 CALL stack_push
CALL stack_pop
VALUE 3 CALL stack_push
VALUE 4 CALL stack_push
CALL stack_pop
CALL stack_pop
CALL stack_pop
RETURN